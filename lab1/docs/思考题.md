1. 在使用 `make menuconfig` 调整 Linux 编译选项的时候，你会看到有些选项是使用 `[M]` 标记的。它们是什么意思？在你的 `init` 启动之前的整个流程中它们会被加载吗？如果不，在正常的 Linux 系统中，它们是怎么被加载的？

   * [M]标记表示编译成模块，该模块可以在需要时动态加载到内核中。在init启动之前的整个流程他们不会被加载。在正常的linux系统中，它们在编译后只生成.o文件，可以将这些.o文件放入linux文件系统中，然后用insmod实现动态加载。

2. 在「构建 `initrd`」的教程中我们创建了一个示例的 init 程序。为什么屏幕上输出 "Hello, Linux!" 之后，Linux 内核就立刻 kernel panic 了？

   * 运行后报错信息为Kernel panic-not syncing : Attempted to kill init! 可见出现Kernel panic的原因是进程被杀死。
   * 原因：一般程序运行完就自动退出了。示例的init程序只是单纯地输出"Hello,Linux!",便return 0,程序运行结束，进程被杀死，故出现了Kernel panic报错信息。

3. 为什么我们编写 C 语言版本的 `init` 程序在编译时需要静态链接？我们能够在这里使用动态链接吗？

   * 静态链接时，在生成可执行文件的时候(链接阶段)，所有需要的函数的二进制代码都被包含到可执行文件中了，这样生成的程序不需要依赖库，可以在任何地方独立执行。
   * 在这里不能使用动态链接。因为动态链接在编译的时候不直接拷贝可执行代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定的代码时，去共享执行内存中已经加载的动态库可执行代码，最终达到运行时连接的目的。而本实验中的init程序是在本地进行链接后，用给定的linux内核在qemu虚拟环境中运行，而用户并未提供动态链接器和所需要的库函数，故无法运行

4. 我们的 MBR 样例程序使用了 BIOS 调用 (`int 0x10`) 以显示文本。Linux 的 `init` 程序也可以用这种办法输出文本吗？为什么？

   * 不能，int0x10属于BIOS中断，这种中断只存在于实模式。而linux工作于保护模式，在保护模式下中断机制发生了很大的变化，原来的中断向量表被IDT（中断描述符表）代替，实模式下能用的BIOS中断在保护模式下已经不能用了。

5. 目前，越来越多的 PC 使用 UEFI 启动。请简述使用 UEFI 时系统启动的流程，并与传统 BIOS 的启动流程比较。

   * UEFI系统的启动流程
     * SEC阶段，主要功能是接收并处理系统启动和重启信号、初始化临时存储区域、作为可信系统的根以及传递系统参数给下一阶段（即PEI），执行流程为加电->Reset Vector->SEC入口函数->PEI入口函数
     * PEI阶段（EFI前期的初始化），主要功能是唤醒CPU及记忆体初始化，为DXE准备执行环境，将需要传递到DXE的信息组成HOB（Handoff Block）列表，最终将控制权转交到DXE手中。
     * DEX阶段，主要功能是执行大部分系统初始化工作，进入此阶段时，内存已经可以被完全使用，因而此阶段可以进行大量的复杂工作。
     * BDS阶段，主要功能是执行启动策略，包括初始化控制台设备、加载必要的设备驱动、根据系统设置加载和执行启动项。如果加载启动项失败，系统将重新执行DXE dispatcher以加载更多的驱动，然后重新尝试加载启动项。
     * TSL阶段，此阶段OS Loader作为一个UEFI应用程序运行，系统资源仍然由UEFI内核控制。当启动服务的ExitBootServices()服务被调用后，系统进入Run Time阶段。（为操作系统加载器准备执行环境）
     * RT阶段，此阶段系统的控制权从UEFI内核转交到OS Loader手中，UEFI占用的各种资源被回收到OS Loader，仅有UEFI运行时服务保留给OS Loader和OS使用。随着OS Loader的执行，OS最终取得对系统的控制权
     * AL阶段，在RT阶段，如果系统（硬件或软件）遇到灾难性错误，系统固件需要提供错误处理和灾难恢复机制，这种机制运行在AL（After Life）阶段

   * BIOS启动流程

     * 当计算机加电后，一般不直接执行操作系统，而是执行系统初始化软件完成基本IO初始化和引导加载功能。简单地说，系统初始化软件就是在操作系统内核运行之前运行的一段小软件。通过这段小软件，可以自检、初始化硬件设备、建立系统的内存空间映射图，从而将系统的软硬件环境带到一个合适的状态，以便为最终调用操作系统内核准备好正确的环境。最终引导加载程序把操作系统内核映像加载到RAM中，并将系统控制权传递给它
  * 上电->CPU初始化->到BIOS启动处进行POST自检->读中断的方式加载各种硬件，完成硬件初始化->进入操作系统启动阶段
   
* 比较
   
  * UEFI的优势
   
    1、通过保护预启动或预引导进程，抵御bootkit攻击，从而提高安全性。
   
    2、缩短了启动时间和从休眠状态恢复的时间。
   
    3、支持容量超过2.2 TB的驱动器。
   
    4、支持64位的现代固件设备驱动程序，系统在启动过程中可以使用它们来对超过172亿GB的内存进行寻址。
   
    5、UEFI硬件可与BIOS结合使用。
   
    6、图形界面，更利于用户对象图形化的操作选择
   
     * BIOS先要对CPU初始化，然后跳转到BIOS启动处进行POST自检，此过程如有严重错误，则电脑会用不同的报警声音提醒，接下来采用读中断的方式加载各种硬件，完成硬件初始化后进入操作系统启动过程。而UEFI则省去了传统的BIOS 自检过程，通过运行预加载环境先直接初始化CPU和内存，CPU和内存若有问题则直接黑屏，其后启动PXE，采用枚举方式搜索各种硬件并加载驱动，完成硬件初始化，之后同样进入操作系统启动过程
     * BIOS是16位汇编语言程序，只能运行在16位实模式，可访问的内存只有1MB，而UEFI是32位或64位高级语言程序（C语言程序），突破实模式限制，可以达到要求的最大寻址
  * UEFI的BIOS启动模式，有两种启动模式，一种是兼容启动模式CSM，还有一种是纯UEFI启动模式。CSM兼容启动模式，是UEFI和传统BIOS两者共存模式，既能用传统BIOS引导模式，也能用新式UEFI启动电脑系统。UEFI启动模式则只能在UEFI引导模式来启动电脑系统
   
  
   
   

