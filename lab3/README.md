学号：PB18111793

姓名：裴启智

## 完善双人聊天室

#### 实现以换行为分隔符的消息分割

* 由于客户端发送的几条信息可能经过多次recv，故对客户端的`send`和服务端的`recv`之间不作任何的假设，只要服务端接收到数据就将其暂存，然后通过不断读取，并根据读取到的结果进行发送：
  * 如果recv到了一条或多条信息，则直接发送并清空buffer
  * 若只recv到了半条消息，则不发送，等待这条消息的换行符到达再发送
  * 若recv到了几条完整的消息但最后一条不完整，则只发送完整的消息，并将最后不完整的部分前移到buffer的最前端

#### 处理可能的 `send` 阻塞

* 检查每次send成功的字节数，如果和需要发送的字节数相同，则发送成功。如果该字节数小于需要发送的字节数，则继续发送剩下的部分，直到判定为全部发送为止

## 利用多线程技术实现多人聊天室

* 请使用g++进行编译
* 每个客户端都有对应的发送和接收线程，且有各自的发送队列
* 首先建立64个线程，两两一组作为某个客户端的服务端线程（一个负责接受，一个负责发送），每个客户端对应一个结构体，在接受线程中进行某个客户端的连接以及写入其他客户端的发送队列，在写入完成后唤醒发送线程，将当前客户端发送队列中的数据发送给客户端
* 某个客户端退出后相应的线程阻塞在accept处，等待新的客户端加入
* 一个已知的bug是如果客户端已达到最大值，再加入一个新的客户端并发送数据，会对原有客户端的稳定性造成一定的影响，在这面没有过多进行优化。但在实验要求的小于等于32个客户端范围内客户端加入、退出、发送信息运转正常，请在小于等于32个客户端的范围内操作

## 利用 IO 复用 / 异步 IO 技术实现多人聊天室

* 请使用g++进行编译
* 每个客户端在可读时读入数据，写入对应的发送队列，在可写时发送
* 因为非阻塞IO下send可能只能成功发送一部分数据，故保留客户端的发送队列的子串用以后续的发送（客户端可写时select响应并进行后续的发送，直至发送完全）
* 同时在线的客户端超过32个的时候，或者在第33个同时在线的客户端进行发送可能会影响原有在线客户端的稳定性，在这方面没有过多进行优化。请在小于等于32个客户端的范围内操作

  

**比较**

第三部分性能较第一二部分有较大的提升，第一二部分发送较大数据的时间明显较长



**教训**

* 尽量不要在for循环中改变循环变量的值，否则可能会出现意想不到的错误
* 字符串及时清空很重要，否则会对后续结果造成影响
* 对“可写”概念的理解：缓冲区还有空间







