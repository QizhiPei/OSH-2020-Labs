# Strace部分

* int brk(void *addr)：改变数据段的大小。当addr指定的值合理且系统有足够的内存空间且该进程不超过其最大数据的大小时，该函数将数据段的末端设置为addr指定的值。成功返回0,失败返回-1

* int access(const char *pathname, int mode)：确定当前进程是否有文件或文件夹的访问权限，即检查目标文件的存取方式（只读、只写等)。如果指定的存取方式有效，则返回0，否则返回-1

* int openat(int dirfd, const char *pathname, int flags)：打开或创建一个文件（和文件描述符相关）。如果成功，则返回一个新的文件描述符，如果失败，返回-1

* int fstat**(int** *fd***, struct stat \****buf)：获取所指文件的状态并填写buf，通过文件描述符*fd*指定要声明的文件。成功返回0,失败返回-1

* void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset)：将文件或设备映射或取消映射到内存中。为进程在虚拟空间中创建一个新的映射，新映射的起始地址在addr中指定，长度由length参数指定

* mprotect(void *addr, size_t len, int prot)：在内存区域设置保护，把自addr开始的、长度为len的内存区的保护属性修改为prot指定的值。成功返回0,失败返回-1

  ​																																	参考：man手册、google和csdn部分内容

# 选做部分

* 完成了"支持 Bash 风格的 TCP 重定向"和"支持基于文件描述符的文件重定向、文件重定向组合"两个选做部分
* 在"支持基于文件描述符的文件重定向、文件重定向组合"部分，在实现"<<"和"<<<"重定向时采用了文件读写作为中介，创建一个临时文件"temp.txt"，在完成相应功能后会检查如果之前是因为"<<"和"<<<"重定向导致该文件被创建的话，会将该文件删除。这种实现方法的前提是不存在"temp.txt"这个文件。如果存在，可能会将其改动并删除，而且这个文件本身的内容可能会影响"<<"和"<<<"重定向的功能。这是一些瑕疵。当然也可以将临时文件的文件名改得比较随机且冗长，这样可以尽量规避这种风险。

# 一些其他的说明

* 因为子进程和父进程都会响应信号，故在代码中让收到信号且有子进程的情况下不进行任何输出。这导致存在子进程的时候收到ctrl+c信号后，可能会出现新的#号输出在同一行的情况

* 请使用`g++ -o sh shell.c`命令生成可执行文件

* 仓库中的ceshi1.c ， ceshi2.c ， ceshi3.c是我自己用来测试"支持基于文件描述符的文件重定向、文件重定向组合"选做部分的代码，生成对应的ceshi1、ceshi2、ceshi3可执行文件，分别对应的测试命令如下：

  ```
  ./ceshi1 10> ceshi.txt
  ./ceshi2 30< ceshi.txt
  ./ceshi3 10>&1 30< ceshi.txt
  ```
  
  助教在检查的时候可以不对这些文件进行编译